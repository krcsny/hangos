// Generated by CoffeeScript 2.3.2
var FX, MasterRecorder, Mic, Mouse, Player, Recorder, Slots, Visual, checkstates, init, setMasterButtons, setbuttons;

Player = new Tone.Player().toMaster();

Mic = new Tone.UserMedia();

Visual = {
  mode: "wave", // "wave"
  waveform: null,
  micform: null,
  ctx: null,
  hsl: function(h, s, l, a) {
    return `hsl(${h * 360}, ${s * 100}%, ${l * 100}%, ${a})`;
  },
  slots: function(w, h) {
    var hw, j, ref, results, s, sw, y;
    sw = w / Slots;
    hw = sw * 0.5;
    results = [];
    for (s = j = 0, ref = Slots - 1; (0 <= ref ? j <= ref : j >= ref); s = 0 <= ref ? ++j : --j) {
      if ((Recorder.slots[s] != null) && Recorder.slots[s].state === "started") {
        this.ctx.fillStyle = this.hsl(0.9 + Math.random() * 0.2, 0.8 + Math.random() * 0.1, 0.3, 0.2 + Math.random() * 0.2);
        this.ctx.fillRect(s * sw, 0, sw, h);
        y = (1 - (Recorder.getEffectValue(s))) * h;
        this.ctx.fillStyle = "#0004";
        this.ctx.beginPath();
        this.ctx.arc(s * sw + hw, y, hw, 0, 2 * Math.PI);
        results.push(this.ctx.fill());
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  drawWaveform: function(values) {
    var h, i, j, len, v, w, x, y;
    w = this.ctx.canvas.width;
    h = this.ctx.canvas.height;
    // @ctx.clearRect(0, 0, w, h)
    this.ctx.fillStyle = (typeof MasterRecorder !== "undefined" && MasterRecorder !== null) && MasterRecorder.isRecording() ? "#F55D3E22" : "#76BED0";
    this.ctx.fillRect(0, 0, w, h);
    this.slots(w, h);
    this.ctx.lineJoin = "bezel";
    this.ctx.strokeStyle = "#000";
    this.ctx.lineWidth = 1 + values[0] * (15 + Math.random() * 5);
    this.ctx.beginPath();
    this.ctx.moveTo(0, 0.5 * h);
// console.log values
    for (i = j = 0, len = values.length; j < len; i = ++j) {
      v = values[i];
      x = (i / values.length) * w;
      y = ((v + 1) / 2) * 2 * h - h * 0.5;
      this.ctx.lineTo(x, y);
    }
    this.ctx.lineTo(w, 0.5 * h);
    return this.ctx.stroke();
  },
  draw: function() {
    this.drawWaveform(Recorder.recording ? this.micform.getValue() : this.waveform.getValue());
    return requestAnimationFrame(Visual.draw.bind(Visual));
  },
  write: function(text) {
    // if @mode is "text"
    return $("#text").html(text);
  },
  resize: function() {
    this.ctx.canvas.width = $("#screen").width();
    return this.ctx.canvas.height = $("#screen").height();
  },
  init: function() {
    if (this.mode === "wave") {
      this.waveform = new Tone.Waveform(256);
      this.micform = new Tone.Waveform(256);
      Tone.Master.fan(this.waveform);
      Mic.connect(this.micform);
      this.ctx = $("canvas").get(0).getContext("2d");
      $(window).resize(Visual.resize.bind(Visual));
      this.resize();
      return this.draw();
    }
  }
};

Slots = 6;

FX = {
  names: ["Tone", "PitchShift", "Freeverb", "Chorus", "PingPongDelay", "BitCrusher", "Distortion", "Reverse"],
  create: function(i, parent) {
    var name, r;
    r = null;
    name = this.names[i];
    switch (name) {
      case "Tone":
        r = new Tone.Limiter(0).toMaster();
        r.sign = "%";
        r.parent = parent;
        r.getVal = function() {
          if (r.parent != null) {
            return Math.sqrt(parent.playbackRate / 6);
          } else {
            return -1;
          }
        };
        r.setVal = function(y) {
          if (r.parent != null) {
            return parent.set("playbackRate", 0.1 + y * y * 6);
          }
        };
        break;
      case "PitchShift":
        r = new Tone.PitchShift(-6).toMaster();
        r.sign = "*";
        r.getVal = function() {
          return (10 + this.pitch) / 36;
        };
        r.setVal = function(y) {
          return r.set("pitch", -10 + 36 * y);
        };
        break;
      case "Freeverb":
        r = new Tone.Freeverb().toMaster();
        r.sign = "&sum;";
        r.getVal = function() {
          return (this.roomSize.value - 0.5) / 0.45;
        };
        r.setVal = function(y) {
          return r.set("roomSize", 0.5 + 0.45 * y);
        };
        break;
      case "Chorus":
        r = new Tone.Chorus().toMaster();
        r.sign = "~";
        r.getVal = function() {
          return (this.depth - 0.7) / 0.3;
        };
        // 1 - ((10 + @pitch) / 24)
        r.setVal = function(y) {
          this.set("frequency", 0.1 + y * 50);
          return this.depth = 0.7 + 0.3 * y;
        };
        break;
      // @delayTime = 1 + 9 * y
      case "Phaser":
        r = new Tone.Phaser().toMaster();
        r.sign = "~";
        r.getVal = function() {
          return this.depth;
        };
        r.setVal = function(y) {
          this.set("frequency", 0.5 + y * 99.5);
          return this.depth = 0.1 + 0.7 * y;
        };
        break;
      case "PingPongDelay":
        r = new Tone.PingPongDelay().toMaster();
        r.sign = ":";
        r.getVal = function() {
          return this.delayTime.value;
        };
        // 1 - ((10 + @pitch) / 24)
        r.setVal = function(y) {
          r.set("maxDelay", y);
          return r.set("delayTime", y);
        };
        break;
      case "BitCrusher":
        r = new Tone.BitCrusher(5).toMaster();
        r.sign = "#";
        r.getVal = function() {
          return 1 - ((this.bits - 3) / 3);
        };
        r.setVal = function(y) {
          return this.set("bits", 6 - Math.round(y * 3));
        };
        break;
      case "Distortion":
        r = new Tone.Distortion().toMaster();
        r.sign = "!";
        r.getVal = function() {
          return this.distortion;
        };
        r.setVal = function(y) {
          return this.set("distortion", y);
        };
        break;
      case "Reverse":
        r = new Tone.Limiter(0).toMaster();
        r.sign = "<";
        r.getVal = function() {
          return -1;
        };
        r.setVal = function() {};
    }
    r.index = i;
    return r;
  }
};

Math.clamp = function(x, min, max) {
  return Math.min(Math.max(x, min), max);
};

MasterRecorder = null;

Recorder = {
  muteOnRec: false,
  recording: false,
  rec: null,
  audioChunks: [],
  audio: null,
  url: null,
  slots: [],
  currentSlot: 0,
  // effects : [
  //   Tone.Master
  //   new Tone.PitchShift(-7).toMaster()
  //   new Tone.PitchShift(12).toMaster()
  //   new Tone.BitCrusher(3).toMaster()
  // ]
  init: function() {
    var s, slot;
    return this.slots = (function() {
      var j, ref, results;
      results = [];
      for (s = j = 0, ref = Slots - 1; (0 <= ref ? j <= ref : j >= ref); s = 0 <= ref ? ++j : --j) {
        slot = new Tone.Player();
        slot.effect = FX.create(0, slot);
        slot.connect(slot.effect);
        slot.loop = true;
        results.push(slot);
      }
      return results;
    })();
  },
  stop: function() {
    return this.rec.stop();
  },
  pushdata: function(e) {
    return this.audioChunks.push(e.data);
  },
  convertData: function() {
    var audioBlob;
    console.log("stopped recording");
    audioBlob = new Blob(this.audioChunks);
    this.url = URL.createObjectURL(audioBlob);
    // @audio = new Audio(@url)
    this.recording = false;
    return this.ready(this.url);
  },
  // audio.play()
  record: function(mic) {
    var stream;
    stream = mic._stream;
    this.recording = true;
    console.log("started recording");
    this.audioChunks = [];
    this.rec = new MediaRecorder(stream);
    this.rec.start();
    this.audioChunks = [];
    this.rec.addEventListener("dataavailable", this.pushdata.bind(this));
    return this.rec.addEventListener("stop", this.convertData.bind(this));
  },
  // setTimeout((() -> Recorder.rec.stop()),3000)
  start: function() {
    Mic.open().then(this.record.bind(this));
    return Tone.Master.mute = this.muteOnRec;
  },
  // navigator.mediaDevices.getUserMedia({ audio: true })
  // .then(@record.bind(Recorder))
  saveFile: function(blob) {
    var a, date, name, url;
    a = $("<a style='display: none;'/>");
    // blob = new Blob(@audioChunks, {type: 'audio/ogg; codecs=opus'})
    url = window.URL.createObjectURL(blob);
    a.attr("href", url);
    date = new Date();
    name = "hangos " + date.toTimeString().substr(0, 9).replace(/:/g, "-") + date.getDate() + "/" + date.getMonth() + "/" + date.getFullYear();
    a.attr("download", name);
    $("body").append(a);
    a[0].click();
    window.URL.revokeObjectURL(url);
    return a.remove();
  },
  ready: function(url, blob) {
    // console.log @audio
    // if @currentSlot is -1
    console.log("setting buffer");
    return new Tone.Buffer(url, this.bufferReady.bind(this));
  },
  bufferReady: function(b) {
    var slot;
    slot = this.slots[this.currentSlot];
    slot.buffer = b;
    slot.buffer.reverse = slot.effect.sign === "<";
    this.togglePlayer(this.currentSlot);
    return Tone.Master.mute = false;
  },
  togglePlayer: function(s) {
    if (Recorder.slots[s].buffer.loaded) {
      if (this.slots[s].state === "started") {
        return this.slots[s].stop();
      } else {
        return this.slots[s].start();
      }
    }
  },
  toggleLooping: function(s) {
    return this.slots[s].loop = !this.slots[s].loop;
  },
  toggleRecord: function(s) {
    // if s is -1
    //   @currentSlot = -1
    if (this.recording) {
      setbuttons(this.currentSlot, "show");
      return this.stop();
    } else {
      this.currentSlot = s;
      setbuttons(this.currentSlot, "hide");
      return this.start();
    }
  },
  cycleEffect: function(s) {
    var slot;
    slot = this.slots[s];
    slot.disconnect(slot.effect);
    slot.effect.dispose();
    slot.effect = FX.create((slot.effect.index + 1) % FX.names.length, slot);
    slot.connect(slot.effect);
    return slot.buffer.reverse = slot.effect.sign === "<";
  },
  getEffectValue: function(s) {
    var e, fx;
    e = this.slots[s].effect.index;
    fx = this.slots[s].effect;
    return fx.getVal();
  },
  setEffect: function(s, y) {
    var slot;
    s = Math.clamp(s, 0, Slots);
    slot = this.slots[s];
    if (slot.state === "started") {
      return slot.effect.setVal(y);
    }
  }
};

setbuttons = function(s, show) {
  var j, k, ref, results, ss, x;
  for (ss = j = 0, ref = Slots - 1; (0 <= ref ? j <= ref : j >= ref); ss = 0 <= ref ? ++j : --j) {
    if (ss !== s) {
      $($("#buttons").children()[ss])[show]();
    }
  }
  results = [];
  for (x = k = 1; k <= 4; x = ++k) {
    results.push($($($("#buttons").children()[s]).children()[x])[show]());
  }
  return results;
};

// $("#buttons:nth-child(#{s}):nth-child(#{x})").hide()
setMasterButtons = function(show) {
  var b, j, results;
  results = [];
  for (b = j = 1; j <= 3; b = ++j) {
    results.push($($("#master").children()[b])[show]());
  }
  return results;
};

checkstates = function() {
  var h, j, playing, ref, results, s;
  playing = false;
  results = [];
  for (s = j = 0, ref = Slots - 1; (0 <= ref ? j <= ref : j >= ref); s = 0 <= ref ? ++j : --j) {
    h = "&empty;";
    if (Recorder.slots[s].state === "started") {
      playing = true;
      h = "&#x25a0;";
    } else if (Recorder.slots[s].buffer.loaded) {
      h = "&#x25b6;";
    }
    results.push($($($("#buttons").children()[s]).children()[1]).html(h));
  }
  return results;
};


// $($($("#phone").children()[2]).children()[1]).html(if playing then "&#x25a0;" else "&#x25b6;")
Mouse = {
  down: false
};

init = function() {
  var buttons, fx, looper, mainplay, mainrec, master, muteonrec, play, record, s, slots, volumeDown, volumeUp;
  slots = (function() {
    var j, ref, results;
    results = [];
    for (s = j = 0, ref = Slots - 1; (0 <= ref ? j <= ref : j >= ref); s = 0 <= ref ? ++j : --j) {
      record = $("<button>", {
        html: "&#x25cf;",
        // html : "&nbsp&#x25cf;&nbsp"
        class: "numpad, record",
        click: function(e) {
          Tone.context.resume();
          s = $(e.currentTarget).parent().index();
          return Recorder.toggleRecord(s);
        }
      });
      play = $("<button>", {
        html: "",
        class: "numpad, play",
        click: function(e) {
          s = $(e.currentTarget).parent().index();
          Recorder.currentSlot = s;
          return Recorder.togglePlayer(s);
        }
      });
      looper = $("<button>", {
        html: "&infin;",
        class: "numpad, loop",
        click: function(e) {
          s = $(e.currentTarget).parent().index();
          Recorder.currentSlot = s;
          Recorder.toggleLooping(s);
          return $(this).html(Recorder.slots[s].loop ? "&infin;" : "&#x21e5;");
        }
      });
      fx = $("<button>", {
        html: "%",
        class: "numpad, effect",
        click: function(e) {
          s = $(e.currentTarget).parent().index();
          Recorder.currentSlot = s;
          Recorder.cycleEffect(s);
          return $(this).html(Recorder.slots[s].effect.sign);
        }
      });
      buttons = [record, play, looper, fx];
      results.push($("<div>", {
        class: "buttonrow",
        html: buttons
      }));
    }
    return results;
  })();
  $("#buttons").html(slots);
  volumeDown = $("<button>", {
    html: "-",
    class: "numpad, masterbutton",
    click: function(e) {
      return Tone.Master.volume.value = Math.clamp(Tone.Master.volume.value - 1, -64, 12);
    }
  });
  volumeUp = $("<button>", {
    html: "+",
    class: "numpad, masterbutton",
    click: function(e) {
      return Tone.Master.volume.value = Math.clamp(Tone.Master.volume.value + 1, -64, 12);
    }
  });
  mainrec = $("<button>", {
    html: "&#x25cf;",
    // html : "&nbsp;"
    class: "numpad, masterbutton, masterrecord",
    click: function(e) {
      if (MasterRecorder.isRecording()) {
        MasterRecorder.finishRecording();
        $("#master").removeClass("record");
        return setMasterButtons("show");
      } else {
        MasterRecorder.startRecording();
        $("#master").addClass("record");
        return setMasterButtons("hide");
      }
    }
  });
  mainplay = $("<button>", {
    html: "&#x25b6;",
    class: "numpad, masterbutton",
    click: function(e) {
      var j, len, playing, ref, results;
      playing = Recorder.slots.reduce((function(a, v) {
        if (a) {
          return a;
        } else {
          return v.state === "started";
        }
      }), false);
      ref = Recorder.slots;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        s = ref[j];
        if (s.buffer.loaded) {
          if (playing) {
            results.push(s.stop());
          } else {
            results.push(s.start());
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  });
  muteonrec = $("<button>", {
    html: "h",
    class: "numpad, masterbutton",
    click: function(e) {
      Recorder.muteOnRec = !Recorder.muteOnRec;
      return $(this).html(Recorder.muteOnRec ? "f" : "h");
    }
  });
  master = $("<div>", {
    class: "buttonrow",
    id: "master",
    html: [mainrec, muteonrec, volumeDown, volumeUp]
  });
  $("#phone").append(master);
  $(window).on("touchstart mousedown", function() {
    return Mouse.down = true;
  });
  $(window).on("touchend mouseup", function() {
    return Mouse.down = false;
  });
  $("#screen").on("touchmove mousemove", function(e) {
    var h, w, x, y;
    if (Mouse.down) {
      $("#text").html(e.offsetX);
      w = Visual.ctx.canvas.width;
      h = Visual.ctx.canvas.height;
      x = e.offsetX;
      y = e.offsetY;
      return Recorder.setEffect(Math.floor((x / w) * Slots), 1 - (y / h));
    }
  });
  Visual.init();
  Recorder.init();
  MasterRecorder = new WebAudioRecorder(Tone.Master, {
    workerDir: "lib/",
    encoding: "mp3"
  });
  MasterRecorder.onComplete = function(rec, blob) {
    return Recorder.saveFile(blob);
  };
  return setInterval(checkstates, 100);
};

init();

//# sourceMappingURL=script.js.map
